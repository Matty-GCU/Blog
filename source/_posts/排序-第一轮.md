---
abbrlink: 6f6caf88
title: 排序-第一轮 刷题笔记
tags:
  - 力扣
  - 排序
categories:
  - 力扣
  - 刷题笔记
  - 第一轮
date: 2022-07-05
updated:
---

# 排序-第一轮 刷题笔记

## 关于*号

题号前面带\*表示自己没有AC，是看题解才AC的。

## [747. 至少是其他数字两倍的最大数](https://leetcode.cn/problems/largest-number-at-least-twice-of-others/)

给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。

请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。

> 示例 1：
>
> 输入：nums = [3,6,1,0]
> 输出：1
> 解释：6 是最大的整数，对于数组中的其他整数，6 至少是数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。
> 示例 2：
>
> 输入：nums = [1,2,3,4]
> 输出：-1
> 解释：4 没有超过 3 的两倍大，所以返回 -1 。
> 示例 3：
>
> 输入：nums = [1]
> 输出：0
> 解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。
>
>
> 提示：
>
> 1 <= nums.length <= 50
> 0 <= nums[i] <= 100
> nums 中的最大元素是唯一的

#### 分析

只要最大元素大于或等于第二大元素的两倍，就能够满足题目所说的“最大元素至少是数组中每个其他数字的两倍”。

#### 解法一：数组映射+排序API  O(N*log(N))  O(1)  21%  78%  1ms  39.2MB

特殊情况：数组长度为1，直接返回0；

除了特殊情况，我的第一反应是，ArrayList.sort排序一下，比较最大值和第二大值，但是这样就丢失了最大值原来的下标。既然是要记住原来下标，而nums数组的长度和元素大小又都很小，那就可以用“数组映射”（本人自己发明的词儿）——这其实是数组映射的经典应用场景——将nums里的元素值映射到该元素在排序前所在下标（nums数组长度1\~50，故arrayMap选用byte型；元素大小0\~100，故arrayMap长度选择101）。

#### 解法二：只找最大和第二大  O(1N)  O(1)  100%  37%  1ms  39.5MB

釜底抽薪！我们需要的其实只有这三个数据：

* 唯一的最大元素
* 唯一的最大元素的下标
* 第二大元素，不一定唯一，但是无需记住下标

那就维护三个变量，遍历一遍数组后排好“前二排行榜”，最后比较一下即可。

这种解法就简单多了，也快很多。时间复杂度马上就降了下来，只是花在一次遍历上。

## [905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)

给你一个整数数组 `nums`，将 `nums` 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。

返回满足此条件的 **任一数组** 作为答案。

> 示例 1：
>
> 输入：nums = [3,1,2,4]
> 输出：[2,4,3,1]
> 解释：[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。
> 示例 2：
>
> 输入：nums = [0]
> 输出：[0]
>
>
> 提示：
>
> 1 <= nums.length <= 5000
> 0 <= nums[i] <= 5000

#### 分析

数组的左边本来就已经有一些偶数元素了，数组的右边也本来就有一些奇数元素了，我们要做的只是把部分“不合群”的元素挑出来放到另一边去。

#### 解法：双指针  O(1N)  O(1)  100%  82%  0ms  42MB

从前找奇数，从后找偶数，然后互换位置，保证下标0\~i都是偶数，下标j~nums.length\-1都是奇数。

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        // 双指针
        int i = 0;
        int j = nums.length - 1;
        // 从前找奇数，从后找偶数，然后互换位置，保证下标0~i都是偶数，下标j~nums.length-1都是奇数
        while(i < j) {

            while(i < j && nums[i] % 2 != 1) {
                i++;
            }
            // 退出上面的循环时，要么i==j（到达边界，不需要交换位置），要么nums[i]是奇数（需要交换位置）

            while(i < j && nums[j] % 2 != 0) {
                j--;
            }
            // 退出上面的循环时，要么i==j（到达边界，不需要交换位置），要么nums[j]是偶数（需要交换位置）

            //如果未到达边界，则交换位置
            if(i < j) {
                int numJ = nums[j];
                nums[j] = nums[i];
                nums[i] = numJ;
                i++;
                j--;
            }
        }
        return nums;
    }
}
```

## [922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

给定一个非负整数数组 `nums`， `nums` 中一半整数是 **奇数** ，一半整数是 **偶数** 。

对数组进行排序，以便当 `nums[i]` 为奇数时，`i` 也是 **奇数** ；当 `nums[i]` 为偶数时， `i` 也是 **偶数** 。

你可以返回 *任何满足上述条件的数组作为答案* 。

> 示例 1：
>
> 输入：nums = [4,2,5,7]
> 输出：[4,5,2,7]
> 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
> 示例 2：
>
> 输入：nums = [2,3]
> 输出：[2,3]
>
>
> 提示：
>
> 2 <= nums.length <= 2 * 10^4
> nums.length 是偶数
> nums 中一半是偶数
> 0 <= nums[i] <= 1000

#### 分析

根据题意可得数组长度为偶数，并且当所有偶数都“就位”，即位于偶数下标时，所有奇数也是“就位”的。

和905题类似，我们只需要用双指针把”不合群“的元素挑出来然后互换位置即可。

既然要看合不合“群”，那么如果划分两个“群”呢？最简单的方式是以偶数下标和奇数下标为区分，这样也方便分开遍历。

#### 解法：双指针  O(1N)  O(1)  96%  14%  2ms  44.2MB

使用双指针，在一个大while循环中，小while遍历偶数下标i，找到值为奇数的元素，再小while遍历奇数下标j，找到值为偶数的元素，然后两个元素值互换即可。

```java
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        // 双指针
        int i = 0;
        int j = 1;

        int len = nums.length;
        while(i < len && j < len) {
            // 遍历偶数下标i，找到值为奇数的元素
            while(i < len && nums[i] % 2 == 0) {
                // 该下标符合条件（偶下标偶值），放过，继续循环
                i += 2;
            }
            // 要么该下标不符合条件（偶下标奇值），要么下标已越界并且所有元素已符合条件（偶下标偶值，奇下标奇值），退出循环

            // 再遍历奇数下标j，找到值为偶数的元素
            while(j < len && nums[j] % 2 == 1) {
                // 该下标符合条件（奇下标奇值），放过，继续循环
                j += 2;
            }
            // 要么该下标不符合条件（奇下标偶值），要么下标已越界并且所有元素已符合条件（偶下标偶值，奇下标奇值），退出循环

            // 若下标未越界，则两者的值互换
            if(i < len) {
                int numsJ = nums[j];
                nums[j] = nums[i];
                nums[i] = numsJ;
                i += 2;
                j += 2;
            }
        }
        return nums;
    }
}
```

2022.7.5





## [937. 重新排列日志文件](https://leetcode.cn/problems/reorder-data-in-log-files/)

给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。

有两种不同类型的日志：

* 字母日志：除标识符之外，所有字均由小写字母组成
* 数字日志：除标识符之外，所有字均由数字组成

请按下述规则将日志重新排序：

* 所有 字母日志 都排在 数字日志 之前。

* 字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。
* 数字日志 应该保留原来的相对顺序。

返回日志的最终顺序。

> 示例 1：
>
> 输入：logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
> 输出：["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
> 解释：
> 字母日志的内容都不同，所以顺序为 "art can", "art zero", "own kit dig" 。
> 数字日志保留原来的相对顺序 "dig1 8 1 5 1", "dig2 3 6" 。
> 示例 2：
>
> 输入：logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
> 输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
>
>
> 提示：
>
> 1 <= logs.length <= 100
> 3 <= logs[i].length <= 100
> logs[i] 中，字与字之间都用 单个 空格分隔
> 题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字

#### 分析

首先我们需要实现稳定排序，这样的话才能保证数字日志之间的相对顺序不变；

其次我们需要自定义排序，这样才能给字母日志排序，因为比较两个字符日志时的情况比较多，要分割，分割完还要分情况比较。

#### 解法一：Arrays.sort  暴力  O(N*log(N))  O(1)  7%  23%  9ms  41.9MB

注意Arrays的sort方法在排对象时是稳定的，比如`sort(T[] a, Comparator<? super T> c)`；只有在排基本数据类型时才是不稳定排序，比如`sort(int[] a)`。

自定义排序，Lambda表达式实现Comparator接口。

另外还要写一个封装方法来判断日志类型。

* 当两个比较元素中只有一个是数字日志时，把数字日志向后排（判为更大）
* 当两个比较元素都是数字日志时，两者的相对顺序不变（判为相等）
* 当两个比较元素都是字母日志时，使用split(" ", 2)将日志分割成“标识符”和“内容”两个部分
  * 若内容不同则比较内容
  * 若内容相同则比较标识符

#### 解法一小优化：O(N*log(N))  O(1)  4ms  42MB  64%  10%

优化1：split方法增加limit参数，即`String[] split(String regex, int limit)`，既省去多余的分隔符匹配运算，也方便后续的比较。

优化2：直接根据每条日志的最后一个字符是不是数字来判断日志类型，不需要分割，因为数字日志的内容部分全都由数字组成。

2022.7.6





## *[976. 三角形的最大周长](https://leetcode.cn/problems/largest-perimeter-triangle/)

给定由一些正数（代表长度）组成的数组 `nums` ，返回 *由其中三个长度组成的、**面积不为零**的三角形的最大周长* 。如果不能形成任何面积不为零的三角形，返回 `0`。

> 示例 1：
>
> 输入：nums = [2,1,2]
> 输出：5
> 示例 2：
>
> 输入：nums = [1,2,1]
> 输出：0
>
>
> 提示：
>
> 3 <= nums.length <= 10^4
> 1 <= nums[i] <= 10^6

#### 分析

三条边构成三角形的必要充分条件：**任意两边和大于第三边**

最暴力的算法当然是三层for，一次试一条边，这样时间复杂度是O(N^3)，肯定会超时。但是除此之外我完全没思路了，只好看官方题解。他是**基于最长边**来试的，而且只判断**相邻三边中的较小两边是否大于最长边**。

引用[蓝田](https://leetcode.cn/u/lan-tian-38/)在官方题解评论区的评论：

> **为什么只需要判断 a + b > c ?**
>
> 正常情况下，对于三条边长，判断能否组成三角形需要判断任何两条边长相加都大于其余的一条边长，即：
>
> ```swift
> a + b > c && a + c > b && b + c > a
> ```
>
> 而如果已知 a<=b<=c，那么必然有：
>
> 1. a + c > b，因为 c >= b，那c加上一个正数一定就比b大了。而题目里说所数都>=1，所以c加上a一定比b大。
> 2. b + c > a，因为b和c至少跟a一样大(b>=a, c>=a)，加起来的结果至少有2a，即 b+c >= 2a > a
>
> 所以最终只需要判断 a + b > c 即可。
>
> **为什么只需要判断数组中相邻的三个数？**
>
> 在固定最后一个数 A[i] 时，前两个数需不需要再往前找呢？
>
> 如果 A[i-2] + A[i-1] <= A[i] ，这三个数一定不能构成三角形，而A[i-3]以及更往前的数，都小于等于A[i-2]，所以再往前取任何两个数只会让相加的值更小，就更不能满足 A[j] + A[k] > A[i]了 (j<i-2, k<i-1, j<k)。所以如果相邻的数构不成三角形，就不需要再固定第三个数并往前找两个数了。
>
> 如果 A[i-2] + A[i-1] > A[i]j，这三个数可以构成三角形，再往前找只会让周长变短，所以也不用再往前了。
>
> 综上，只需要判断相邻的三个数。

#### 官方解法：排序+贪心  O(N*log(N))  Ω(logN)  99%  60%  8ms  41.6MB

> 官方给的这个空间复杂度我不是很理解……评论区也有人问，不过暂时没人回答这个问题。

```java
class Solution {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        for(int i = nums.length - 1; i >= 2; i--) {
            if(nums[i - 2] + nums[i - 1] > nums[i]) {
               return nums[i - 2] + nums[i - 1] + nums[i];
            }
        }
        return 0;
    }
}
```

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

> 示例 1：
>
> 输入：nums = [-4,-1,0,3,10]
> 输出：[0,1,9,16,100]
> 解释：平方后，数组变为 [16,1,0,9,100]
> 排序后，数组变为 [0,1,9,16,100]
> 示例 2：
>
> 输入：nums = [-7,-3,2,3,11]
> 输出：[4,9,9,49,121]
>
>
> 提示：
>
> 1 <= nums.length <= 10^4
> -10^4 <= nums[i] <= 10^4
> nums 已按 非递减顺序 排序
>
> **进阶：**
>
> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题

#### 分析

暴力解很简单，直接平方完排序一下结果就出来了，但是时间复杂度达不到O(N)。

我们可以利用题目“nums 已按 非递减顺序 排序”的条件，通过两个指针从数组的左右两边来遍历它，因为绝对值最大的数肯定在原数组的最左边或者最右边，在每一轮遍历中，我们都选择那个最大的，然后放到刚声明的新数组的最右边去，然后收缩两个指针的范围，再次寻找绝对值最大的数。

#### 解法一：纯暴力解  32%  28%  O(N*log(N))  O(log(N))  4ms  43.3MB

> 复杂度分析
>
> 时间复杂度：O(n \log n)O(nlogn)，其中 nn 是数组 \textit{nums}nums 的长度。
>
> 空间复杂度：O(\log n)O(logn)。除了存储答案的数组以外，我们需要 O(\log n)O(logn) 的栈空间进行排序。

用for循环遍历一次变成平方，再用Arrays.sort排序一次即可。

但是这样没有利用到”已按 非递减顺序 排序“这个条件，因此达不到时间复杂度的进阶要求。

#### 解法二：双指针收缩遍历+链表存储  O(N)  O(N)  33%  18%  3ms  43.4MB

*和解法二优化的思路完全一致，只是用LinkedList存储，插入用addFirst方法，最后还要用迭代器将链表中所有元素依次取出放回原数组并返回原数组的引用。*

#### 解法二优化：双指针收缩遍历+普通数组存储  O(N)  O(N)  100%  18%  1ms  43.3MB

既然链表做的永远都是头插入这一种操作，而且最后还要转换成int数组，那还不如我一开始就声明一个int数组，反正数组长度是固定的，只要声明一个尾指针，从后（length-1）往前（0）插入即可。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 要想时间O(N)那就不可能用常规的排序算法了。通常可以结合题目已有条件用双指针达到O(N)时间。
        int i = 0;
        int j = nums.length - 1;
        // 要根据绝对值把负数穿插到正数旁边的话，肯定要用到O(N)额外空间的，除非在原地排序，但我们现在要的是O(N)时间的算法。
        int[] newNums = new int[nums.length];
        int tail = newNums.length - 1;

        // 左右两边都可能是绝对值最大的数，所以边收缩边遍历
        while(nums[i] < 0 && i < j) {
            if(nums[j] > - nums[i]) {
                newNums[tail--] = nums[j] * nums[j];
                j--;
            }
            else if(nums[j] < - nums[i]) {
                newNums[tail--] = nums[i] * nums[i];
                i++;
            }
            else {
                newNums[tail--] = nums[j] * nums[j];
                j--;
                newNums[tail--] = nums[i] * nums[i];
                i++;
            }
        }
        // 退出循环有三种情况：
        // 一种是nums[i] >= 0，
        if(nums[i] >= 0) {
            // 此时nums[i~j]都是未被加入newNums的非负整数
            while(i <= j) {
                newNums[tail--] = nums[j] * nums[j];
                j--;
            }
        }
        // 第二种情况是i==j，
        else if(i == j) {
            // 此时只有nums[i或j]未被加入newNums
            newNums[tail--] = nums[i] * nums[i];
        }
        // 第三种情况是i=j+1时（当最大负数和最小非负整数的绝对值相等时就会出现这种特殊情况），
        // 此时所有元素均已被加入newNums，无需其他操作

        return newNums;
    }
}
```

2022.7.7